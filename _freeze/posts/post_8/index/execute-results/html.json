{
  "hash": "9801431dd52490335f5b453558547072",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Türkiye ve Çevresinde Gerçekleşen Depremlerin Animasyonlu Harita ile Gösterilmesi\"\nauthor: \"Uraz Akgül\"\ndate: \"2024-04-20\"\n# date-modified: last-modified\ndate-format: \"MMMM D, YYYY\"\ncategories: [Harita, Deprem]\nimage: \"imgs/feb_23.PNG\"\nexecute:\n  eval: false\n---\n\nAnimasyonlu haritalar, zaman içinde değişen verileri görselleştiren etkili bir yöntemdir. Örneğin, Türkiye ve çevresinde gerçekleşen depremleri animasyonlu bir harita üzerinde göstermek, deprem aktivitesinin zamanla nasıl değiştiğini ve hangi bölgelerin daha fazla risk altında olduğunu görsel olarak görmemize yardımcı olabilir.\n\nAnimasyonlu haritayı oluşturmak için kullanacağımız verilere USGS (United States Geological Survey) API ile ulaşacağız.\n\n**Kullanılacak Kütüphaneler**\n\n::: {#598782af .cell execution_count=1}\n``` {.python .cell-code}\nimport requests\nimport pandas as pd\nimport os\nimport time\nimport folium\nfrom folium.plugins import HeatMap\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\nfrom PIL import Image, ImageDraw, ImageFont\nfrom pathlib import Path\nimport imageio\nimport shutil\n```\n:::\n\n\n**API ile Verilerin Çekilmesi ve Kullanılabilir Formata Dönüştürülmesi**\n\n::: {#e620ebda .cell execution_count=2}\n``` {.python .cell-code}\nstart = '2014-01-01'\nmin_mag = 3\nlat = 39.1458\nlon = 34.1614\nmax_rad_km = 1000\n\nurl = f'https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&starttime={start}&minmagnitude={min_mag}&latitude={lat}&longitude={lon}&maxradiuskm={max_rad_km}'\nresponse = requests.get(url)\ndata = response.json()\n\ndf = pd.DataFrame({\n    'Place': [feature['properties']['place'] for feature in data['features']],\n    'Magnitude': [feature['properties']['mag'] for feature in data['features']],\n    'Time': [pd.to_datetime(feature['properties']['time'], unit='ms').strftime('%Y-%m-%d') for feature in data['features']],\n    'Latitude': [feature['geometry']['coordinates'][1] for feature in data['features']],\n    'Longitude': [feature['geometry']['coordinates'][0] for feature in data['features']]\n})\n```\n:::\n\n\nYukarıdaki kodda, verilen parametrelerle USGS API'ını kullanarak deprem verilerini çekiyoruz. Başlangıç tarihini (`start`) `'2014-01-01'` ve minimum deprem büyüklüğünü (`min_mag`) `3` olarak belirledik. Ayrıca, enlem (`lat`) `39.1458` ve boylam (`lon`) `34.1614` olacak şekilde Türkiye'nin koordinatlarına yakın ve maksimum `1000` kilometrelik yarıçapa (`max_rad_km`) sahip bir bölgeyi sorguluyoruz. Son olarak, API'dan gelen verileri işleyerek bir DataFrame oluşturuyoruz. Bu DataFrame, depremlerin yerini (`Place`), büyüklüğünü (`Magnitude`), zamanını (`Time`) ve enlem-boylam koordinatlarını (`Latitude`-`Longitude`) içeriyor.\n\nAylık bir seri ile çalışacağımız için tarihlerdeki (`Time` sütunu) günleri `01` ile değiştiriyoruz.\n\n::: {#9852bbcb .cell execution_count=3}\n``` {.python .cell-code}\ndf['Time'] = df['Time'].str.replace(r'-\\d{2}$', '-01', regex=True)\n```\n:::\n\n\n**Haritaların Yapılması ve HTML-PNG Formatlarında Kaydedilmesi**\n\n::: {#8e86781e .cell execution_count=4}\n``` {.python .cell-code}\nchrome_options = Options()\nchrome_options.add_argument('--start-fullscreen')\n\nunique_dates = df['Time'].unique()\nunique_dates.sort()\n\nturkey_latlon = [39, 35]\n\ndelay = 5\n\nfont = ImageFont.load_default()\nfont_size = 36\n\nfor unique_date in unique_dates:\n\n    filtered_df = df[df['Time'] == unique_date]\n    filtered_df = filtered_df[['Latitude', 'Longitude', 'Magnitude']]\n    turkey_map = folium.Map(location=turkey_latlon, zoom_start=6, tiles='cartodbdark_matter')\n    HeatMap(data=filtered_df, radius=15).add_to(turkey_map)\n\n    html_filename = f'turkey_heatmap_{unique_date}.html'\n    turkey_map.save(html_filename)\n\n    browser = webdriver.Chrome(options=chrome_options)\n    browser.get(os.path.abspath(html_filename))\n    time.sleep(delay)\n\n    screenshot_filename = f'turkey_heatmap_{unique_date}.png'\n    browser.save_screenshot(screenshot_filename)\n\n    browser.quit()\n\n    img = Image.open(screenshot_filename)\n    draw = ImageDraw.Draw(img)\n    font = ImageFont.truetype('arial.ttf', font_size)\n    draw.text((10, img.height - 50), pd.to_datetime(unique_date).strftime('%B %Y'), font=font, fill=(255, 255, 255))\n    img.save(screenshot_filename)\n\n    os.remove(html_filename)\n    print(f'{html_filename} loaded in the browser and screenshot {screenshot_filename} captured.')\n```\n:::\n\n\nYukarıdaki kodda, her bir tarih döngüde kullanılacağı için tekil tarihleri `unique_dates` değişkenine gönderip bu tarihleri eskiden yeniye doğru olacak şekilde sıralıyoruz. Türkiye'nin koordinatlarını tanımladığımız ve haritaların merkezi olacak değerler `turkey_latlon` değişkeninde bulunuyor. Her işlemde `5` saniyelik bir bekleme süresi olacak. Bunu `delay` değişkeninde tutuyoruz. Resimlerin üzerinde görünecek yazılara ait varsayılan font ve font büyüklüğü değerleri olan `arial.ttf` ve `36` sırasıyla `font` ve `font_size` değişkenlerinde bulunuyor. Her döngüde açılacak tarayıcıların ekranı kapsayacak şekilde olmasını istediğimiz için `'--start-fullscreen'` olacak şekilde ayarlama da yaptık.\n\nDöngüde 7 kod grubu bulunmaktadır. İlk grup, tarih filtresi yapıp haritayı oluşturuyor. İkinci grup, haritayı içinde bulunduğu dizine HTML formatında kaydediyor. Üçüncü grup, HTML formatında kaydedilen dosyayı tarayıcıda açıyor ve açtıktan sonra belirlenen süre kadar bekletiyor. Dördüncü grup, ekran görüntüsü alıyor ve içinde bulunduğu dizine PNG formatında kaydediyor. Beşinci grup, açılan tarayıcıyı kapatıyor. Altıncı grup, resim üzerinde yazı işlemlerini yapıyor. Yedinci ve son grup, kaydedilen HTML dosyalarını siliyor ve ekrana bilgi veriyor.\n\n**Animasyonlu Harita Yapımı ve GIF Formatında Kaydedilmesi**\n\nÇalışmanın odak noktasını bu başlık altında göreceğiz.\n\n::: {#7322ca36 .cell execution_count=5}\n``` {.python .cell-code}\nimage_path = Path()\nimages = list(image_path.glob('*.png'))\nimage_list = [imageio.v3.imread(file_name) for file_name in images]\nimageio.mimwrite('Turkey_Earthquake.gif', image_list, fps=2)\n_ = [file.unlink() for file in images]\n\nshutil.move('Turkey_Earthquake.gif', 'imgs/Turkey_Earthquake.gif')\n```\n:::\n\n\nYukarıdaki kodda ilk olarak, `Path()` fonksiyonunu çağırarak bir dosya yolu nesnesi oluşturuyor ve bunu `image_path` değişkenine atıyoruz. Ardından, bu dosya yolu nesnesi üzerinde `.glob()` yöntemini kullanarak tüm PNG dosyalarını alıyor ve `images` listesine atıyoruz. `imageio` modülünü kullanarak her bir PNG dosyasını `imageio.v3.imread()` fonksiyonuyla okuyor ve bu okunan görüntüleri `image_list` listesine ekliyoruz. `imageio.mimwrite()` fonksiyonuyla `image_list` içindeki görüntüleri kullanarak bir GIF dosyası oluşturuyoruz. Oluşturduğumuz GIF dosyasının ismini `'Turkey_Earthquake.gif'` olarak belirliyor ve saniyede 2 kare (`fps=2`) hızında olacak şekilde ayarlıyoruz. Daha sonra, artık gereksiz hale gelmiş olan PNG dosyalarını tek tek sildiriyoruz. Bu işlem için bir liste dönülüyor ve her bir dosya `unlink()` yöntemi kullanılarak siliniyor. Son olarak, `shutil.move()` fonksiyonunu kullanarak oluşturduğumuz GIF dosyasını `'imgs/'` dizini altına taşıyoruz.\n\n![](imgs/Turkey_Earthquake.gif)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}